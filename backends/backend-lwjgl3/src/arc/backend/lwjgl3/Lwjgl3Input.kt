package arc.backend.lwjgl3

import arc.Input
import arc.graphics.gl.HdpiMode
import arc.input.InputEventQueue
import arc.input.KeyCode
import arc.math.Mathf
import arc.util.Disposable
import org.lwjgl.glfw.GLFW
import org.lwjgl.glfw.GLFWCharCallback
import org.lwjgl.glfw.GLFWCursorPosCallback
import org.lwjgl.glfw.GLFWKeyCallback
import org.lwjgl.glfw.GLFWMouseButtonCallback
import org.lwjgl.glfw.GLFWScrollCallback
import java.util.Arrays
import kotlin.math.max

class Lwjgl3Input(val window: Lwjgl3Window) : Input(), Disposable{
    private val queue = InputEventQueue()
    private val keycodeToGlfwKey = IntArray(KeyCode.all.size){ -1 }
    private val justPressedButtons = BooleanArray(GLFW.GLFW_MOUSE_BUTTON_LAST + 1)

    private var mouseX = 0
    private var mouseY = 0
    private var logicalMouseX = 0
    private var logicalMouseY = 0
    private var deltaX = 0
    private var deltaY = 0
    private var mousePressed = 0
    private var justTouched = false

    private val keyCallback = object : GLFWKeyCallback(){
        override fun invoke(windowHandle: Long, key: Int, scancode: Int, action: Int, mods: Int){
            handleKey(key, action)
        }
    }

    private val charCallback = object : GLFWCharCallback(){
        override fun invoke(windowHandle: Long, codepoint: Int){
            // Ignore private-use characters generated by special keys (macOS).
            if((codepoint and 0xff00) == 0xf700) return

            val chars = Character.toChars(codepoint)
            for(char in chars){
                queue.keyTyped(char)
            }
            requestRendering()
        }
    }

    private val scrollCallback = object : GLFWScrollCallback(){
        override fun invoke(windowHandle: Long, scrollX: Double, scrollY: Double){
            queue.scrolled(-fixSign(scrollX.toFloat()), -fixSign(scrollY.toFloat()))
            requestRendering()
        }
    }

    private val cursorPosCallback = object : GLFWCursorPosCallback(){
        override fun invoke(windowHandle: Long, x: Double, y: Double){
            val graphics = window.graphics ?: return

            val newLogicalX = x.toInt()
            val newLogicalY = graphics.height - y.toInt()
            val logicalDeltaX = newLogicalX - logicalMouseX
            val logicalDeltaY = newLogicalY - logicalMouseY

            logicalMouseX = newLogicalX
            logicalMouseY = newLogicalY

            if(window.config.hdpiMode == HdpiMode.pixels){
                val xScale = graphics.backBufferWidth.toFloat() / graphics.width.toFloat()
                val yScale = graphics.backBufferHeight.toFloat() / graphics.height.toFloat()

                mouseX = (newLogicalX * xScale).toInt()
                mouseY = (newLogicalY * yScale).toInt()
                deltaX = (logicalDeltaX * xScale).toInt()
                deltaY = (logicalDeltaY * yScale).toInt()
            }else{
                mouseX = newLogicalX
                mouseY = newLogicalY
                deltaX = logicalDeltaX
                deltaY = logicalDeltaY
            }

            if(mousePressed > 0){
                queue.touchDragged(mouseX, mouseY, 0)
            }else{
                queue.mouseMoved(mouseX, mouseY)
            }

            requestRendering()
        }
    }

    private val mouseButtonCallback = object : GLFWMouseButtonCallback(){
        override fun invoke(windowHandle: Long, button: Int, action: Int, mods: Int){
            val mapped = toKeyCode(button) ?: return

            if(action == GLFW.GLFW_PRESS){
                mousePressed++
                justTouched = true
                if(button in justPressedButtons.indices){
                    justPressedButtons[button] = true
                }
                queue.touchDown(mouseX, mouseY, 0, mapped)
            }else if(action == GLFW.GLFW_RELEASE){
                mousePressed = max(0, mousePressed - 1)
                queue.touchUp(mouseX, mouseY, 0, mapped)
            }else{
                return
            }

            requestRendering()
        }
    }

    init{
        rebuildKeyNameMap()
        windowHandleChanged(window.windowHandle)
    }

    private fun handleKey(key: Int, action: Int){
        val code = getGdxKeyCode(key)
        if(code == KeyCode.unknown) return

        when(action){
            GLFW.GLFW_PRESS -> queue.keyDown(code)
            GLFW.GLFW_RELEASE -> queue.keyUp(code)
            GLFW.GLFW_REPEAT -> {}
            else -> return
        }

        // Match SDL input behavior: special control keys emit keyTyped manually.
        if(action == GLFW.GLFW_PRESS || action == GLFW.GLFW_REPEAT){
            val special = characterForKeyCode(code)
            if(special.code != 0){
                queue.keyTyped(special)
            }
        }

        requestRendering()
    }

    private fun requestRendering(){
        window.graphics?.requestRendering()
    }

    private fun rebuildKeyNameMap(){
        Arrays.fill(keycodeToGlfwKey, -1)
        for(glfw in 0..GLFW.GLFW_KEY_LAST){
            val key = getGdxKeyCode(glfw)
            if(key != KeyCode.unknown && keycodeToGlfwKey[key.ordinal] == -1){
                keycodeToGlfwKey[key.ordinal] = glfw
            }
        }
    }

    private fun toKeyCode(button: Int): KeyCode?{
        return when(button){
            GLFW.GLFW_MOUSE_BUTTON_LEFT -> KeyCode.mouseLeft
            GLFW.GLFW_MOUSE_BUTTON_RIGHT -> KeyCode.mouseRight
            GLFW.GLFW_MOUSE_BUTTON_MIDDLE -> KeyCode.mouseMiddle
            GLFW.GLFW_MOUSE_BUTTON_4 -> KeyCode.mouseBack
            GLFW.GLFW_MOUSE_BUTTON_5 -> KeyCode.mouseForward
            else -> null
        }
    }

    private fun fixSign(value: Float): Float{
        return if(Mathf.equal(value, 0f)) 0f else Mathf.sign(value).toFloat()
    }

    fun resetPollingStates(){
        justTouched = false
        deltaX = 0
        deltaY = 0
        Arrays.fill(justPressedButtons, false)

        queue.setProcessor(null)
        queue.drain()

        keyboard.postUpdate()
    }

    fun windowHandleChanged(windowHandle: Long){
        resetPollingStates()
        GLFW.glfwSetKeyCallback(windowHandle, keyCallback)
        GLFW.glfwSetCharCallback(windowHandle, charCallback)
        GLFW.glfwSetScrollCallback(windowHandle, scrollCallback)
        GLFW.glfwSetCursorPosCallback(windowHandle, cursorPosCallback)
        GLFW.glfwSetMouseButtonCallback(windowHandle, mouseButtonCallback)
    }

    fun update(){
        queue.setProcessor(inputMultiplexer)
        queue.drain()
    }

    fun prepareNext(){
        keyboard.postUpdate()
        justTouched = false
        Arrays.fill(justPressedButtons, false)
        deltaX = 0
        deltaY = 0
    }

    fun isButtonPressed(button: Int): Boolean{
        return button in 0..GLFW.GLFW_MOUSE_BUTTON_LAST &&
            GLFW.glfwGetMouseButton(window.windowHandle, button) == GLFW.GLFW_PRESS
    }

    fun isButtonJustPressed(button: Int): Boolean{
        return button in justPressedButtons.indices && justPressedButtons[button]
    }

    var isCursorCatched: Boolean
        get() = GLFW.glfwGetInputMode(window.windowHandle, GLFW.GLFW_CURSOR) == GLFW.GLFW_CURSOR_DISABLED
        set(catched){
            GLFW.glfwSetInputMode(
                window.windowHandle,
                GLFW.GLFW_CURSOR,
                if(catched) GLFW.GLFW_CURSOR_DISABLED else GLFW.GLFW_CURSOR_NORMAL
            )
        }

    fun setCursorPosition(x: Int, y: Int){
        var targetX = x
        var targetY = y
        val graphics = window.graphics
        if(graphics != null && window.config.hdpiMode == HdpiMode.pixels){
            val xScale = graphics.width / graphics.backBufferWidth.toFloat()
            val yScale = graphics.height / graphics.backBufferHeight.toFloat()
            targetX = (targetX * xScale).toInt()
            targetY = (targetY * yScale).toInt()
        }

        GLFW.glfwSetCursorPos(window.windowHandle, targetX.toDouble(), targetY.toDouble())
        cursorPosCallback.invoke(window.windowHandle, targetX.toDouble(), targetY.toDouble())
    }

    private fun characterForKeyCode(key: KeyCode): Char{
        return when(key){
            KeyCode.backspace -> 8.toChar()
            KeyCode.tab -> '\t'
            KeyCode.forwardDel, KeyCode.del -> 127.toChar()
            KeyCode.dpadCenter, KeyCode.enter -> '\n'
            else -> 0.toChar()
        }
    }

    fun getGdxKeyCode(lwjglKeyCode: Int): KeyCode{
        return when(lwjglKeyCode){
            GLFW.GLFW_KEY_SPACE -> KeyCode.space
            GLFW.GLFW_KEY_APOSTROPHE -> KeyCode.apostrophe
            GLFW.GLFW_KEY_COMMA -> KeyCode.comma
            GLFW.GLFW_KEY_MINUS -> KeyCode.minus
            GLFW.GLFW_KEY_PERIOD -> KeyCode.period
            GLFW.GLFW_KEY_SLASH -> KeyCode.slash
            GLFW.GLFW_KEY_0 -> KeyCode.num0
            GLFW.GLFW_KEY_1 -> KeyCode.num1
            GLFW.GLFW_KEY_2 -> KeyCode.num2
            GLFW.GLFW_KEY_3 -> KeyCode.num3
            GLFW.GLFW_KEY_4 -> KeyCode.num4
            GLFW.GLFW_KEY_5 -> KeyCode.num5
            GLFW.GLFW_KEY_6 -> KeyCode.num6
            GLFW.GLFW_KEY_7 -> KeyCode.num7
            GLFW.GLFW_KEY_8 -> KeyCode.num8
            GLFW.GLFW_KEY_9 -> KeyCode.num9
            GLFW.GLFW_KEY_SEMICOLON -> KeyCode.semicolon
            GLFW.GLFW_KEY_EQUAL -> KeyCode.equals
            GLFW.GLFW_KEY_A -> KeyCode.a
            GLFW.GLFW_KEY_B -> KeyCode.b
            GLFW.GLFW_KEY_C -> KeyCode.c
            GLFW.GLFW_KEY_D -> KeyCode.d
            GLFW.GLFW_KEY_E -> KeyCode.e
            GLFW.GLFW_KEY_F -> KeyCode.f
            GLFW.GLFW_KEY_G -> KeyCode.g
            GLFW.GLFW_KEY_H -> KeyCode.h
            GLFW.GLFW_KEY_I -> KeyCode.i
            GLFW.GLFW_KEY_J -> KeyCode.j
            GLFW.GLFW_KEY_K -> KeyCode.k
            GLFW.GLFW_KEY_L -> KeyCode.l
            GLFW.GLFW_KEY_M -> KeyCode.m
            GLFW.GLFW_KEY_N -> KeyCode.n
            GLFW.GLFW_KEY_O -> KeyCode.o
            GLFW.GLFW_KEY_P -> KeyCode.p
            GLFW.GLFW_KEY_Q -> KeyCode.q
            GLFW.GLFW_KEY_R -> KeyCode.r
            GLFW.GLFW_KEY_S -> KeyCode.s
            GLFW.GLFW_KEY_T -> KeyCode.t
            GLFW.GLFW_KEY_U -> KeyCode.u
            GLFW.GLFW_KEY_V -> KeyCode.v
            GLFW.GLFW_KEY_W -> KeyCode.w
            GLFW.GLFW_KEY_X -> KeyCode.x
            GLFW.GLFW_KEY_Y -> KeyCode.y
            GLFW.GLFW_KEY_Z -> KeyCode.z
            GLFW.GLFW_KEY_LEFT_BRACKET -> KeyCode.leftBracket
            GLFW.GLFW_KEY_BACKSLASH -> KeyCode.backslash
            GLFW.GLFW_KEY_RIGHT_BRACKET -> KeyCode.rightBracket
            GLFW.GLFW_KEY_GRAVE_ACCENT -> KeyCode.backtick
            GLFW.GLFW_KEY_ESCAPE -> KeyCode.escape
            GLFW.GLFW_KEY_ENTER -> KeyCode.enter
            GLFW.GLFW_KEY_TAB -> KeyCode.tab
            GLFW.GLFW_KEY_BACKSPACE -> KeyCode.backspace
            GLFW.GLFW_KEY_INSERT -> KeyCode.insert
            GLFW.GLFW_KEY_DELETE -> KeyCode.del
            GLFW.GLFW_KEY_RIGHT -> KeyCode.right
            GLFW.GLFW_KEY_LEFT -> KeyCode.left
            GLFW.GLFW_KEY_DOWN -> KeyCode.down
            GLFW.GLFW_KEY_UP -> KeyCode.up
            GLFW.GLFW_KEY_PAGE_UP -> KeyCode.pageUp
            GLFW.GLFW_KEY_PAGE_DOWN -> KeyCode.pageDown
            GLFW.GLFW_KEY_HOME -> KeyCode.home
            GLFW.GLFW_KEY_END -> KeyCode.end
            GLFW.GLFW_KEY_CAPS_LOCK -> KeyCode.capsLock
            GLFW.GLFW_KEY_SCROLL_LOCK -> KeyCode.scrollLock
            GLFW.GLFW_KEY_PRINT_SCREEN -> KeyCode.printScreen
            GLFW.GLFW_KEY_PAUSE -> KeyCode.pause
            GLFW.GLFW_KEY_F1 -> KeyCode.f1
            GLFW.GLFW_KEY_F2 -> KeyCode.f2
            GLFW.GLFW_KEY_F3 -> KeyCode.f3
            GLFW.GLFW_KEY_F4 -> KeyCode.f4
            GLFW.GLFW_KEY_F5 -> KeyCode.f5
            GLFW.GLFW_KEY_F6 -> KeyCode.f6
            GLFW.GLFW_KEY_F7 -> KeyCode.f7
            GLFW.GLFW_KEY_F8 -> KeyCode.f8
            GLFW.GLFW_KEY_F9 -> KeyCode.f9
            GLFW.GLFW_KEY_F10 -> KeyCode.f10
            GLFW.GLFW_KEY_F11 -> KeyCode.f11
            GLFW.GLFW_KEY_F12 -> KeyCode.f12
            GLFW.GLFW_KEY_NUM_LOCK -> KeyCode.num
            GLFW.GLFW_KEY_KP_0 -> KeyCode.numpad0
            GLFW.GLFW_KEY_KP_1 -> KeyCode.numpad1
            GLFW.GLFW_KEY_KP_2 -> KeyCode.numpad2
            GLFW.GLFW_KEY_KP_3 -> KeyCode.numpad3
            GLFW.GLFW_KEY_KP_4 -> KeyCode.numpad4
            GLFW.GLFW_KEY_KP_5 -> KeyCode.numpad5
            GLFW.GLFW_KEY_KP_6 -> KeyCode.numpad6
            GLFW.GLFW_KEY_KP_7 -> KeyCode.numpad7
            GLFW.GLFW_KEY_KP_8 -> KeyCode.numpad8
            GLFW.GLFW_KEY_KP_9 -> KeyCode.numpad9
            GLFW.GLFW_KEY_KP_DECIMAL -> KeyCode.period
            GLFW.GLFW_KEY_KP_DIVIDE -> KeyCode.slash
            GLFW.GLFW_KEY_KP_MULTIPLY -> KeyCode.star
            GLFW.GLFW_KEY_KP_SUBTRACT -> KeyCode.minus
            GLFW.GLFW_KEY_KP_ADD -> KeyCode.plus
            GLFW.GLFW_KEY_KP_ENTER -> KeyCode.enter
            GLFW.GLFW_KEY_KP_EQUAL -> KeyCode.equals
            GLFW.GLFW_KEY_LEFT_SHIFT -> KeyCode.shiftLeft
            GLFW.GLFW_KEY_LEFT_CONTROL -> KeyCode.controlLeft
            GLFW.GLFW_KEY_LEFT_ALT -> KeyCode.altLeft
            GLFW.GLFW_KEY_LEFT_SUPER -> KeyCode.sym
            GLFW.GLFW_KEY_RIGHT_SHIFT -> KeyCode.shiftRight
            GLFW.GLFW_KEY_RIGHT_CONTROL -> KeyCode.controlRight
            GLFW.GLFW_KEY_RIGHT_ALT -> KeyCode.altRight
            GLFW.GLFW_KEY_RIGHT_SUPER -> KeyCode.sym
            GLFW.GLFW_KEY_MENU -> KeyCode.menu
            else -> KeyCode.unknown
        }
    }

    override fun getKeyName(code: KeyCode): String{
        val glfwCode = keycodeToGlfwKey[code.ordinal]
        if(glfwCode != -1){
            val name = GLFW.glfwGetKeyName(glfwCode, GLFW.glfwGetKeyScancode(glfwCode))
            if(!name.isNullOrBlank()){
                return name
            }
        }
        return super.getKeyName(code)
    }

    override fun mouseX(): Int{
        return mouseX
    }

    override fun mouseX(pointer: Int): Int{
        return if(pointer == 0) mouseX else 0
    }

    override fun deltaX(): Int{
        return deltaX
    }

    override fun deltaX(pointer: Int): Int{
        return if(pointer == 0) deltaX else 0
    }

    override fun mouseY(): Int{
        return mouseY
    }

    override fun mouseY(pointer: Int): Int{
        return if(pointer == 0) mouseY else 0
    }

    override fun deltaY(): Int{
        return deltaY
    }

    override fun deltaY(pointer: Int): Int{
        return if(pointer == 0) deltaY else 0
    }

    override fun isTouched(): Boolean{
        return keyDown(KeyCode.mouseLeft) || keyDown(KeyCode.mouseRight)
    }

    override fun justTouched(): Boolean{
        return justTouched
    }

    override fun isTouched(pointer: Int): Boolean{
        return pointer == 0 && isTouched()
    }

    override fun getCurrentEventTime(): Long{
        return queue.currentEventTime
    }

    override fun dispose(){
        keyCallback.free()
        charCallback.free()
        scrollCallback.free()
        cursorPosCallback.free()
        mouseButtonCallback.free()
    }
}
